% This class implements an event-based estimation system using GTSAM and
% the barebones for building up a minimal, ideal SLAM system. The system is
% event-based and responds to a sequence of events which are time stamped
% and served in order. 
%
% We actually use a real-time variant of GTSAM called ISAM2 which pulls a
% lot of tricks to speed up the way stuff is incrementally added into the
% graph. This requires a little bit of management with ordering, so the
% relevant bits are all hidden.
%
% To implement your SLAM system, you will need to extend this class to
% implement additional methods to support odometry, incorporating GPS
% measurements and the laser. The subclasses can be found in the answers
% package.

% Please do not edit this file directly unless you need to. Rather, please
% use subclasses. Templates are provided.

classdef ISAMLocalizationSystem < minislam.localization.VehicleLocalizationSystem
    
    properties(Access = protected)        
        % The most recently created vehicle pose and associated pose key.
        % This corresponds to the vertex on the very front of the graph and
        % is the vertex which describes the currentEventTime.
        currentVehiclePose;
        
        % The key of the most recently created vertex.
        currentVehiclePoseKey;
        
        % This stores the vehicle keys for ease of looking up
        vehiclePoseKeyStore;
        
        % This stores the landmark keys for ease of looking up
        landmarkIDKeyStore;

    end
    
    properties(Access = private)
        
        % A counter which is used to create unambiguous keys. This must be
        % an integer.
        vehicleVertexCounter;
        
        % Parameters used to manage ISAM.
        isamParams;
        
        % The ISAM system.
        isam;
                
        % The graph used for performing estimation.
        newFactors;
        
        % The values in the graph.
        newValues;
        
        % Flag indicates if we need to merge
        mergeRequiredIntoISAMRequired;
        
        % Flag indicates if the cached values and marginals are sufficent
        lastOptimizedValues;
        lastOptimizedMarginals;z
    end
            
    methods(Access = public)
        
        % Construct a new GTSAM system.
        function this = ISAMLocalizationSystem()
            
            % Call the base class constructor
            this = this@minislam.localization.VehicleLocalizationSystem();
            
            % Set the parameters
            this.isamParams = gtsam.ISAM2Params();
            this.isamParams.setFactorization('CHOLESKY');
            this.isamParams.setRelinearizeSkip(10);

            % Create the ISAM system
            this.isam = gtsam.ISAM2(this.isamParams);
            
            % Create the factor graph and the associated values. These need to be kept in "lock step" with one another. 
            this.newFactors = gtsam.NonlinearFactorGraph();
            this.newValues = gtsam.Values();
            
            % Create the vehicle counter which is used to generate the vehicle verticles.
            this.vehicleVertexCounter = uint32(0);
            
            % Vehicle pose key store
            this.vehiclePoseKeyStore = minislam.utils.KeyStore();
            
            % Landmkark key store
            this.landmarkIDKeyStore = minislam.utils.KeyStore();
        end
        
        % Recommend if an optimization is a good idea. Based on an event,
        % some activities (e.g., such as loop closing) can have a very big
        % impact on the estimates. Therefore, this method returns if the
        % localization algorithm thinks optimizing is a good idea. Here we
        % always return true. This shouldn't hurt anything, but stuff can
        % run much more slowly as a result.
        function recommendation = recommendOptimization(this)
            recommendation = rem(this.stepNumber, 1) == 0;
        end
        
        % This method runs the graph optimiser and the outputs of the
        % optimisation are used as the initial conditions for the next
        % round of the graph. This makes it possible to iterative compute
        % solutions as more information becomes available over time.
        function optimize(this)
            
            % If nothing has changed, return
            if (this.mergeRequiredIntoISAMRequired == false)
                return
            end
            
            try
                this.isam.update(this.newFactors, this.newValues);
                this.newFactors = gtsam.NonlinearFactorGraph();
                this.newValues = gtsam.Values();
                this.mergeRequiredIntoISAMRequired = false;
            catch ex
                keyboard
            end
            
            % We always compute the latest results to update the vehicle
            % pose
            this.lastOptimizedValues = this.isam.calculateEstimate();
            
            %factorGraph = this.isam.getFactorsUnsafe();            
            %this.lastOptimizedMarginals =  gtsam.Marginals(factorGraph, this.lastOptimizedValues);

            % Set the current pose to the optimised value
            this.currentVehiclePose = this.lastOptimizedValues.atPose2(this.currentVehiclePoseKey);
        end
        
        function [x, P] = getCurrentMeanAndCovarianceEstimate(this)
            
            x = this.lastOptimizedValues.atPose2(this.currentVehiclePoseKey);

            
            try
                P = this.isam.marginalCovariance(this.currentVehiclePoseKey)
                % The returned covariance appears to be rotated in a
                % strange way relative to global coordinates. This rotates
                % the covariance to the global frame. Not sure why it's
                % needed, but there is zero documentation on the matter...
                R = eye(3);%[cos(theta) -sin(theta) 0;sin(theta) cos(theta) 0;0 0 1];
                P = R * P * R';
            catch e
                keyboard
            end
        end
        
        % Return two cell arrays providing mean and covariance data
        function [x, P] = getCurrentLandmarkEstimates(this, optimizeIfNeeded)
            if (nargin == 1)
                optimizeIfNeeded = true;
            end
            
            if ((optimizeIfNeeded == true) || (isempty(this.lastOptimizedValues) == true))     
                this.optimize();
            end
            
            landmarkKeys = this.landmarkIDKeyStore.values();
            
            numLandmarks = length(landmarkKeys);
            
            x = zeros(2, numLandmarks);            
            P = zeros(2, 2, numLandmarks);
            
            % For 3D landmarks change to:
            %x = zeros(3, numLandmarks);            
            %P = zeros(3, 3, numLandmarks);
            
            for n = 1 : numLandmarks
                landmarkKey = landmarkKeys{n};
                x(:, n) = this.lastOptimizedValues.atPoint2(landmarkKey).vector();
                % For 3D landmarks change to:
                %x(:, n) = this.lastOptimizedValues.atPoint3(landmarkKey).vector();
                P(:, :, n) = this.isam.marginalCovariance(landmarkKey);
            end
        end
    end
        
    % These are the methods you will need to overload
    methods(Access = protected)
                        
        % Declare bodies all of these methods. This makes it possible to
        % instantiate this object, although it will flip out and cause an
        % error.
        
        function handleInitialConditionEvent(this, event)
            % Create the first vehicle vertex. The boolean flag shows
            % whether we add a prior to it or not.
            this.createFirstVehiclePose(event.data, event.covariance);
            this.currentTime = event.time;
            this.mergeRequiredIntoISAMRequired = true;
            this.initialized = true;
        end
        
        function handleGPSEvent(this, event)
            error('Implement this method for part 1');
        end
        
        function handleLaserEvent(this, event)
            error('Implement this method for part 2');
        end
        
        function handleCameraEvent(this, event)
            error('Not supported this year');
        end
        
        function [relativeTransform, relativeTransformCovariance] = computeRelativeVehicleTransformAndCovariance(this)
            error('Implement this method for part 1');
        end
    end
    
    methods(Access = protected)
                
        function addNewFactor(this, newFactor)
            this.newFactors.add(newFactor);
            this.mergeRequiredIntoISAMRequired = true;
        end
        
        function addNewVariable(this, newKey, initialValue)
            this.newValues.insert(newKey, initialValue);
            this.mergeRequiredIntoISAMRequired = true;
        end
        
        function addNewFactorAndVariable(this, newKey, newFactor, initialValue)
            this.newFactors.add(newFactor);
            this.newValues.insert(newKey, initialValue);
            this.mergeRequiredIntoISAMRequired = true;
        end
        
        % This method does two things. First, it creates a new vehicle pose
        % associated with the current time. Second, it does other stuff.
        % Whee!
        function advanceToEventTime(this, time)            
            % Work out the time step length. This is the interval we
            % will predict over.
            dT = time - this.currentTime;
            
            % Nothing to do if it's really close to the last time
            if (abs(dT) < 1e-3)
                return
            end
            
            % Nothing to do if the control input is tiny - the robot didn't
            % go anywhere
            if (norm(this.u) < 1e-6)
                return
            end
            
            % Get the 2D kinematic model. This has to be turned into a 3D
            % pose for GTSAM to work.
            [relativePose, relativePoseCovariance] = ...
                this.computeRelativeVehicleTransformAndCovariance(dT);

            % Pad with stabilising noise
            relativePoseCovariance(3,3) = relativePoseCovariance(3,3) + (dT *0.01*pi/180)^2;

            % If debugging is enabled, check to see that the noise
            % covariance is good
            if (this.debug == true)
                try                
                    chol(relativePoseCovariance);
                catch e
                    warning('The relativeTransformCovariance matrix is not positive semidefinite.');
                    relativePoseCovariance
                    keyboard
                end
            end
            
            % The vehicle pose we are going to attach to
            newVehiclePoseKey = this.getNewVehiclePoseKey();
           
            % Construct the covariance matrix for the process noise
            relativePoseNoise = gtsam.noiseModel.Gaussian.Covariance(relativePoseCovariance);
            
            % Assign the initial value to the vehicle pose. This is given
            % by predicting with the process model
            newVehiclePose = this.currentVehiclePose.compose(relativePose);
            
            newOdometryFactor = gtsam.BetweenFactorPose2(this.currentVehiclePoseKey, ...
                newVehiclePoseKey, relativePose, relativePoseNoise);

            % Insert the new factorand the new initial value
            this.addNewFactorAndVariable(newVehiclePoseKey, newOdometryFactor, newVehiclePose);
            
            % Store the last vehicle pose and pose key
            this.currentVehiclePose = newVehiclePose;
            this.currentVehiclePoseKey = newVehiclePoseKey;
        end
        
        % This helper function serves up unique keys for the robot.
        function vehiclePoseKey = getNewVehiclePoseKey(this)
            vehiclePoseKey = gtsam.symbol('x', this.vehicleVertexCounter);
            this.vehicleVertexCounter = this.vehicleVertexCounter + 1;
        end

        % This helper function serves up unique keys for the robot.
        function landmarkKey = getLandmarkKey(~, landmarkID)            
            landmarkKey = gtsam.symbol('l', int32(landmarkID));
        end                
    end
    
    methods(Access = private)

        % This method creates the first vehicle pose in the graph. It
        % creates a Pose2 and puts it at the origin with a small prior covariance.  
        function createFirstVehiclePose(this, priorState, priorCovariance)
            
            % Allocate a vehicle key
            this.currentVehiclePoseKey = this.getNewVehiclePoseKey();
            
            % Set up the initial condition prior factor and add it
            initialPoseValue = gtsam.Pose2(gtsam.Rot2(priorState(3)), gtsam.Point2(priorState(1:2)));
            initialPoseNoise = gtsam.noiseModel.Gaussian.Covariance(1e-6*eye(3) + priorCovariance);
            initialPoseFactor = gtsam.PriorFactorPose2(this.currentVehiclePoseKey, initialPoseValue, initialPoseNoise);            
            this.addNewFactorAndVariable(this.currentVehiclePoseKey, initialPoseFactor, initialPoseValue)
            
            % Store the vehicle pose
            this.currentVehiclePose = initialPoseValue;
        end 
        
    end
    
end
