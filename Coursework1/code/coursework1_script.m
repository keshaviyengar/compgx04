%COMPGX04: Robot Vision and Navigation
%Keshav Iyengar
%Coursework 1: Integrated Navigation for a Robotic Lawnmower
clear variables;
close all;

%define constants
Define_Constants

%extract pseudo_ranges and pseudo_range_rates
M = csvread('Pseudo_ranges.csv');
V = csvread('Pseudo_range_rates.csv');
time = M(2:end,1);
sat_id = M(1,2:end);
pseudo_ranges = M(2:end,2:end);
pseudo_range_rates = V(2:end,2:end);

%% 1. Compute inital starting position and velocity
% Don't know where on earth we are so use LSE to converge to position at
% first epoch
initial_ned_pos = SingleEpochPosNoInit(time,sat_id,pseudo_ranges);
disp('Initial Position found.')
initial_ned_vel = [0;0;0]; %assume starting stationary

%% 2. Perform LSE for all epochs for position and velocity
outlier_meas = [0 0];
[ecef_positions,ecef_vels,d_rho_c,dd_rho_c,outlier_list] = MultiEpochPosAndVel(time,sat_id,...
    pseudo_ranges,pseudo_range_rates,initial_ned_pos,initial_ned_vel);
disp('LSE for all epochs done.')

%% Determine outlier satellites
for epoch=1:size(time,1)
    [res,sat_idx] = max(abs(outlier_list(epoch,:)));
    if res > 0
       outlier_meas = [outlier_meas;epoch,sat_idx]; 
    end
end
%satellite_idx is a mess, remove from psuedo ranges and psuedo_range_rates
%and sat_id
pseudo_ranges(:,3) = [];
pseudo_range_rates(:,3) = [];
sat_id(3) = [];
%% 4. Perform GNSS Only Kalman Filter
gnss_ned_solutions = GNSSOnlyKalmanFilter(time,sat_id,pseudo_ranges,pseudo_range_rates, ...
    ecef_positions(:,1),ecef_vels(:,1),d_rho_c,dd_rho_c);

%% 4. DR Solution
%extract compass and wheel speed data
DR = csvread('Dead_reckoning.csv');
wheel_speeds = DR(:,2:5);
fl_speed = DR(:,2);
fr_speed = DR(:,3);
bl_speed = DR(:,4);
br_speed = DR(:,5);
gyro = DR(:,6);
heading = DR(:,7)*deg_to_rad;
%with skid steer, front left/back left front right/back right should be the same unless we are slipping
%assume no slipping
%simply average the fr/br and fl/bl, then sum and divide by 2 the result
%http://www.ijmmm.org/papers/077-A009.pdf
%gives us vax and vay in the center of the mower
speed = (mean([fr_speed br_speed],2) + mean([fl_speed br_speed],2))/2;
[dr_ned_positions,dr_ned_velocities] = DeadReckoningOnly(time,speed,heading,initial_ned_pos);


%% 5. DR/ECEF GNSS Kalman Integration
[int_ned_positions,int_ned_velocities] = DR_GNSS_Integration(time,gnss_ned_solutions(1:3,:),...
    gnss_ned_solutions(4:6,:),dr_ned_positions,dr_ned_velocities);

%% 6. Heading/Gyro Kalman Integration
%compute gyro solution with initial conditions
gyro_heading = zeros(1,size(time,1));
gyro_heading(1) = heading(1);
for epoch=2:size(time,1)
   gyro_heading(epoch) = gyro_heading(epoch-1) + gyro(epoch)*0.5; 
end
heading_solutions = GyroOnlyKalmanFilter(time,heading,gyro_heading);

output = [time rad_to_deg*int_ned_positions(1:2,:)' int_ned_velocities(1:2,:)' heading_solutions'];

plotter(time,gnss_ned_solutions,[dr_ned_positions;dr_ned_velocities],[int_ned_positions;int_ned_velocities])

%plot heading
figure
plot(time,gyro_heading*rad_to_deg)
hold on
plot(time,heading_solutions*rad_to_deg)
title('Heading Solutions for DR-Only,Integrated KF')
legend('DR-Only','Integrated KF')
xlabel('Time (seconds)')
ylabel('Angle w.r.t to North in Degrees')
%find that the error generated by the gyroscope integration is directly
%equal to the difference between the dr solution and the magnetometer
%heading solution. Thus the integrated KF simply gives us the heading
%solution

%output to csv file
csvwrite('Output_Profile.csv','output')

